{"ast":null,"code":"const heapSort = async (array, key, speed, updateFn) => {\n  let totalComparisons = 0;\n  let totalSwaps = 0;\n  const heapify = async (n, i) => {\n    // Pseudo code step 12: Initialize heapify\n    await updateFn(array, [i], false, speed, null, 12);\n    let largest = i;\n    const left = 2 * i + 1;\n    const right = 2 * i + 2;\n\n    // Pseudo code step 13-14: Compare with left child\n    if (left < n) {\n      totalComparisons++;\n      await updateFn(array, [largest, left], false, speed, null, 13);\n      if (array[left][key] > array[largest][key]) {\n        largest = left;\n      }\n    }\n\n    // Pseudo code step 15-16: Compare with right child\n    if (right < n) {\n      totalComparisons++;\n      await updateFn(array, [largest, right], false, speed, null, 15);\n      if (array[right][key] > array[largest][key]) {\n        largest = right;\n      }\n    }\n\n    // Pseudo code step 17-18: Swap if needed and recursively heapify\n    if (largest !== i) {\n      await updateFn(array, [i, largest], true, speed, null, 17);\n\n      // Swap\n      const temp = array[i];\n      array[i] = array[largest];\n      array[largest] = temp;\n      totalSwaps++;\n\n      // Recursively heapify the affected sub-tree\n      await heapify(n, largest);\n    }\n  };\n\n  // Build max heap\n  // Pseudo code step 8-9: Build max heap\n  await updateFn(array, [], false, speed, null, 8);\n  for (let i = Math.floor(array.length / 2) - 1; i >= 0; i--) {\n    await updateFn(array, [i], false, speed, null, 9);\n    await heapify(array.length, i);\n  }\n\n  // Extract elements from heap one by one\n  // Pseudo code step 3-4: Sort array using heap\n  await updateFn(array, [], false, speed, null, 3);\n  for (let i = array.length - 1; i > 0; i--) {\n    // Pseudo code step 4: Swap root with last element\n    await updateFn(array, [0, i], true, speed, null, 4);\n\n    // Move current root to end\n    const temp = array[0];\n    array[0] = array[i];\n    array[i] = temp;\n    totalSwaps++;\n\n    // Pseudo code step 5: Heapify reduced heap\n    await updateFn(array, [0], false, speed, null, 5);\n    await heapify(i, 0);\n  }\n\n  // Final update with metrics\n  await updateFn(array, [], false, speed, {\n    totalComparisons,\n    totalSwaps\n  }, 19);\n  return array;\n};\nexport default heapSort;","map":{"version":3,"names":["heapSort","array","key","speed","updateFn","totalComparisons","totalSwaps","heapify","n","i","largest","left","right","temp","Math","floor","length"],"sources":["/Users/shreya/Desktop/DAA(sem-4)/lab-EL/StockSorting_Visualizer/src/algorithms/heapSort.js"],"sourcesContent":["const heapSort = async (array, key, speed, updateFn) => {\n  let totalComparisons = 0;\n  let totalSwaps = 0;\n\n  const heapify = async (n, i) => {\n    // Pseudo code step 12: Initialize heapify\n    await updateFn(array, [i], false, speed, null, 12);\n    \n    let largest = i;\n    const left = 2 * i + 1;\n    const right = 2 * i + 2;\n\n    // Pseudo code step 13-14: Compare with left child\n    if (left < n) {\n      totalComparisons++;\n      await updateFn(array, [largest, left], false, speed, null, 13);\n      if (array[left][key] > array[largest][key]) {\n        largest = left;\n      }\n    }\n\n    // Pseudo code step 15-16: Compare with right child\n    if (right < n) {\n      totalComparisons++;\n      await updateFn(array, [largest, right], false, speed, null, 15);\n      if (array[right][key] > array[largest][key]) {\n        largest = right;\n      }\n    }\n\n    // Pseudo code step 17-18: Swap if needed and recursively heapify\n    if (largest !== i) {\n      await updateFn(array, [i, largest], true, speed, null, 17);\n      \n      // Swap\n      const temp = array[i];\n      array[i] = array[largest];\n      array[largest] = temp;\n      totalSwaps++;\n\n      // Recursively heapify the affected sub-tree\n      await heapify(n, largest);\n    }\n  };\n\n  // Build max heap\n  // Pseudo code step 8-9: Build max heap\n  await updateFn(array, [], false, speed, null, 8);\n  \n  for (let i = Math.floor(array.length / 2) - 1; i >= 0; i--) {\n    await updateFn(array, [i], false, speed, null, 9);\n    await heapify(array.length, i);\n  }\n\n  // Extract elements from heap one by one\n  // Pseudo code step 3-4: Sort array using heap\n  await updateFn(array, [], false, speed, null, 3);\n  \n  for (let i = array.length - 1; i > 0; i--) {\n    // Pseudo code step 4: Swap root with last element\n    await updateFn(array, [0, i], true, speed, null, 4);\n    \n    // Move current root to end\n    const temp = array[0];\n    array[0] = array[i];\n    array[i] = temp;\n    totalSwaps++;\n\n    // Pseudo code step 5: Heapify reduced heap\n    await updateFn(array, [0], false, speed, null, 5);\n    await heapify(i, 0);\n  }\n\n  // Final update with metrics\n  await updateFn(array, [], false, speed, {\n    totalComparisons,\n    totalSwaps\n  }, 19);\n\n  return array;\n};\n\nexport default heapSort;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}