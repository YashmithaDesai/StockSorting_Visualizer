{"ast":null,"code":"export async function heapSort(array, key, speed, updateFn) {\n  const n = array.length;\n\n  // Build max heap\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    await heapify(array, n, i, key, speed, updateFn);\n  }\n\n  // Extract elements from heap one by one\n  for (let i = n - 1; i > 0; i--) {\n    // Move current root to end\n    [array[0], array[i]] = [array[i], array[0]];\n    await updateFn(array, [0, i], true, speed);\n\n    // Call max heapify on the reduced heap\n    await heapify(array, i, 0, key, speed, updateFn);\n  }\n  return array;\n}\nasync function heapify(array, n, i, key, speed, updateFn) {\n  let largest = i;\n  const left = 2 * i + 1;\n  const right = 2 * i + 2;\n\n  // Compare with left child\n  if (left < n) {\n    await updateFn(array, [largest, left], false, speed);\n    if (array[left][key] > array[largest][key]) {\n      largest = left;\n    }\n  }\n\n  // Compare with right child\n  if (right < n) {\n    await updateFn(array, [largest, right], false, speed);\n    if (array[right][key] > array[largest][key]) {\n      largest = right;\n    }\n  }\n\n  // If largest is not root\n  if (largest !== i) {\n    [array[i], array[largest]] = [array[largest], array[i]];\n    await updateFn(array, [i, largest], true, speed);\n\n    // Recursively heapify the affected sub-tree\n    await heapify(array, n, largest, key, speed, updateFn);\n  }\n}","map":{"version":3,"names":["heapSort","array","key","speed","updateFn","n","length","i","Math","floor","heapify","largest","left","right"],"sources":["/Users/shreya/Desktop/DAA(sem-4)/lab-EL/StockSorting_Visualizer/src/algorithms/heapSort.js"],"sourcesContent":["export async function heapSort(array, key, speed, updateFn) {\n  const n = array.length;\n\n  // Build max heap\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    await heapify(array, n, i, key, speed, updateFn);\n  }\n\n  // Extract elements from heap one by one\n  for (let i = n - 1; i > 0; i--) {\n    // Move current root to end\n    [array[0], array[i]] = [array[i], array[0]];\n    await updateFn(array, [0, i], true, speed);\n\n    // Call max heapify on the reduced heap\n    await heapify(array, i, 0, key, speed, updateFn);\n  }\n\n  return array;\n}\n\nasync function heapify(array, n, i, key, speed, updateFn) {\n  let largest = i;\n  const left = 2 * i + 1;\n  const right = 2 * i + 2;\n\n  // Compare with left child\n  if (left < n) {\n    await updateFn(array, [largest, left], false, speed);\n    if (array[left][key] > array[largest][key]) {\n      largest = left;\n    }\n  }\n\n  // Compare with right child\n  if (right < n) {\n    await updateFn(array, [largest, right], false, speed);\n    if (array[right][key] > array[largest][key]) {\n      largest = right;\n    }\n  }\n\n  // If largest is not root\n  if (largest !== i) {\n    [array[i], array[largest]] = [array[largest], array[i]];\n    await updateFn(array, [i, largest], true, speed);\n\n    // Recursively heapify the affected sub-tree\n    await heapify(array, n, largest, key, speed, updateFn);\n  }\n}\n"],"mappings":"AAAA,OAAO,eAAeA,QAAQA,CAACC,KAAK,EAAEC,GAAG,EAAEC,KAAK,EAAEC,QAAQ,EAAE;EAC1D,MAAMC,CAAC,GAAGJ,KAAK,CAACK,MAAM;;EAEtB;EACA,KAAK,IAAIC,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACJ,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAEE,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC/C,MAAMG,OAAO,CAACT,KAAK,EAAEI,CAAC,EAAEE,CAAC,EAAEL,GAAG,EAAEC,KAAK,EAAEC,QAAQ,CAAC;EAClD;;EAEA;EACA,KAAK,IAAIG,CAAC,GAAGF,CAAC,GAAG,CAAC,EAAEE,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC9B;IACA,CAACN,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAACM,CAAC,CAAC,CAAC,GAAG,CAACN,KAAK,CAACM,CAAC,CAAC,EAAEN,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3C,MAAMG,QAAQ,CAACH,KAAK,EAAE,CAAC,CAAC,EAAEM,CAAC,CAAC,EAAE,IAAI,EAAEJ,KAAK,CAAC;;IAE1C;IACA,MAAMO,OAAO,CAACT,KAAK,EAAEM,CAAC,EAAE,CAAC,EAAEL,GAAG,EAAEC,KAAK,EAAEC,QAAQ,CAAC;EAClD;EAEA,OAAOH,KAAK;AACd;AAEA,eAAeS,OAAOA,CAACT,KAAK,EAAEI,CAAC,EAAEE,CAAC,EAAEL,GAAG,EAAEC,KAAK,EAAEC,QAAQ,EAAE;EACxD,IAAIO,OAAO,GAAGJ,CAAC;EACf,MAAMK,IAAI,GAAG,CAAC,GAAGL,CAAC,GAAG,CAAC;EACtB,MAAMM,KAAK,GAAG,CAAC,GAAGN,CAAC,GAAG,CAAC;;EAEvB;EACA,IAAIK,IAAI,GAAGP,CAAC,EAAE;IACZ,MAAMD,QAAQ,CAACH,KAAK,EAAE,CAACU,OAAO,EAAEC,IAAI,CAAC,EAAE,KAAK,EAAET,KAAK,CAAC;IACpD,IAAIF,KAAK,CAACW,IAAI,CAAC,CAACV,GAAG,CAAC,GAAGD,KAAK,CAACU,OAAO,CAAC,CAACT,GAAG,CAAC,EAAE;MAC1CS,OAAO,GAAGC,IAAI;IAChB;EACF;;EAEA;EACA,IAAIC,KAAK,GAAGR,CAAC,EAAE;IACb,MAAMD,QAAQ,CAACH,KAAK,EAAE,CAACU,OAAO,EAAEE,KAAK,CAAC,EAAE,KAAK,EAAEV,KAAK,CAAC;IACrD,IAAIF,KAAK,CAACY,KAAK,CAAC,CAACX,GAAG,CAAC,GAAGD,KAAK,CAACU,OAAO,CAAC,CAACT,GAAG,CAAC,EAAE;MAC3CS,OAAO,GAAGE,KAAK;IACjB;EACF;;EAEA;EACA,IAAIF,OAAO,KAAKJ,CAAC,EAAE;IACjB,CAACN,KAAK,CAACM,CAAC,CAAC,EAAEN,KAAK,CAACU,OAAO,CAAC,CAAC,GAAG,CAACV,KAAK,CAACU,OAAO,CAAC,EAAEV,KAAK,CAACM,CAAC,CAAC,CAAC;IACvD,MAAMH,QAAQ,CAACH,KAAK,EAAE,CAACM,CAAC,EAAEI,OAAO,CAAC,EAAE,IAAI,EAAER,KAAK,CAAC;;IAEhD;IACA,MAAMO,OAAO,CAACT,KAAK,EAAEI,CAAC,EAAEM,OAAO,EAAET,GAAG,EAAEC,KAAK,EAAEC,QAAQ,CAAC;EACxD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}