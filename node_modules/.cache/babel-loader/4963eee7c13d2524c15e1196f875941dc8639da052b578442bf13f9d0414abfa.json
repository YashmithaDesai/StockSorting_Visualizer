{"ast":null,"code":"var _jsxFileName = \"/Users/shreya/Desktop/DAA(sem-4)/lab-EL/StockSorting_Visualizer/src/components/AlgorithmInfo/AlgorithmExplanation.js\";\nimport React from 'react';\nimport './AlgorithmExplanation.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst algorithmInfo = {\n  bubble: {\n    name: 'Bubble Sort',\n    description: 'Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.',\n    timeComplexity: {\n      best: 'O(n)',\n      average: 'O(n²)',\n      worst: 'O(n²)'\n    },\n    spaceComplexity: 'O(1)',\n    pseudocode: `procedure bubbleSort(A: list of sortable items)\n    n = length(A)\n    repeat\n        swapped = false\n        for i = 1 to n-1 inclusive do\n            if A[i-1] > A[i] then\n                swap(A[i-1], A[i])\n                swapped = true\n            end if\n        end for\n    until not swapped\nend procedure`\n  },\n  quick: {\n    name: 'Quick Sort',\n    description: 'Quick Sort is a divide-and-conquer algorithm that works by selecting a pivot element and partitioning the array around it.',\n    timeComplexity: {\n      best: 'O(n log n)',\n      average: 'O(n log n)',\n      worst: 'O(n²)'\n    },\n    spaceComplexity: 'O(log n)',\n    pseudocode: `procedure quickSort(A: list of sortable items, low: int, high: int)\n    if low < high then\n        pivot = partition(A, low, high)\n        quickSort(A, low, pivot - 1)\n        quickSort(A, pivot + 1, high)\n    end if\nend procedure\n\nprocedure partition(A: list of sortable items, low: int, high: int)\n    pivot = A[high]\n    i = low - 1\n    for j = low to high - 1 do\n        if A[j] ≤ pivot then\n            i = i + 1\n            swap(A[i], A[j])\n        end if\n    end for\n    swap(A[i + 1], A[high])\n    return i + 1\nend procedure`\n  },\n  merge: {\n    name: 'Merge Sort',\n    description: 'Merge Sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves.',\n    timeComplexity: {\n      best: 'O(n log n)',\n      average: 'O(n log n)',\n      worst: 'O(n log n)'\n    },\n    spaceComplexity: 'O(n)',\n    pseudocode: `procedure mergeSort(A: list of sortable items, left: int, right: int)\n    if left < right then\n        middle = (left + right) / 2\n        mergeSort(A, left, middle)\n        mergeSort(A, middle + 1, right)\n        merge(A, left, middle, right)\n    end if\nend procedure\n\nprocedure merge(A: list, left: int, middle: int, right: int)\n    create temporary arrays L and R\n    copy A[left..middle] to L\n    copy A[middle+1..right] to R\n    i = 0, j = 0, k = left\n    while i < length(L) and j < length(R) do\n        if L[i] <= R[j] then\n            A[k] = L[i]\n            i = i + 1\n        else\n            A[k] = R[j]\n            j = j + 1\n        end if\n        k = k + 1\n    end while\n    copy remaining elements of L and R if any\nend procedure`\n  },\n  heap: {\n    name: 'Heap Sort',\n    description: 'Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. It builds a max-heap and repeatedly extracts the maximum element.',\n    timeComplexity: {\n      best: 'O(n log n)',\n      average: 'O(n log n)',\n      worst: 'O(n log n)'\n    },\n    spaceComplexity: 'O(1)',\n    pseudocode: `procedure heapSort(A: list of sortable items)\n    buildMaxHeap(A)\n    for i = length(A) to 2 do\n        swap(A[1], A[i])\n        heapSize = heapSize - 1\n        maxHeapify(A, 1)\n    end for\nend procedure\n\nprocedure buildMaxHeap(A: list of sortable items)\n    heapSize = length(A)\n    for i = length(A)/2 to 1 do\n        maxHeapify(A, i)\n    end for\nend procedure\n\nprocedure maxHeapify(A: list of sortable items, i: int)\n    left = 2i\n    right = 2i + 1\n    if left ≤ heapSize and A[left] > A[i] then\n        largest = left\n    else\n        largest = i\n    end if\n    if right ≤ heapSize and A[right] > A[largest] then\n        largest = right\n    end if\n    if largest ≠ i then\n        swap(A[i], A[largest])\n        maxHeapify(A, largest)\n    end if\nend procedure`\n  }\n};\nconst AlgorithmExplanation = ({\n  activeAlgorithm\n}) => {\n  const algorithm = algorithmInfo[activeAlgorithm];\n  if (!algorithm) return null;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"algorithm-explanation\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: algorithm.name\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 144,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"algorithm-description\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: algorithm.description\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 146,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 145,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"complexity-info\",\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Time Complexity\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 149,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: [\"Best Case: \", algorithm.timeComplexity.best]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 151,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [\"Average Case: \", algorithm.timeComplexity.average]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 152,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [\"Worst Case: \", algorithm.timeComplexity.worst]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 153,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 150,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Space Complexity\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 155,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: algorithm.spaceComplexity\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 156,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 148,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"pseudocode\",\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Pseudocode\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 159,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"pre\", {\n        children: algorithm.pseudocode\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 160,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 158,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 143,\n    columnNumber: 5\n  }, this);\n};\n_c = AlgorithmExplanation;\nexport default AlgorithmExplanation;\nvar _c;\n$RefreshReg$(_c, \"AlgorithmExplanation\");","map":{"version":3,"names":["React","jsxDEV","_jsxDEV","algorithmInfo","bubble","name","description","timeComplexity","best","average","worst","spaceComplexity","pseudocode","quick","merge","heap","AlgorithmExplanation","activeAlgorithm","algorithm","className","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/shreya/Desktop/DAA(sem-4)/lab-EL/StockSorting_Visualizer/src/components/AlgorithmInfo/AlgorithmExplanation.js"],"sourcesContent":["import React from 'react';\nimport './AlgorithmExplanation.css';\n\nconst algorithmInfo = {\n  bubble: {\n    name: 'Bubble Sort',\n    description: 'Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.',\n    timeComplexity: {\n      best: 'O(n)',\n      average: 'O(n²)',\n      worst: 'O(n²)'\n    },\n    spaceComplexity: 'O(1)',\n    pseudocode: `procedure bubbleSort(A: list of sortable items)\n    n = length(A)\n    repeat\n        swapped = false\n        for i = 1 to n-1 inclusive do\n            if A[i-1] > A[i] then\n                swap(A[i-1], A[i])\n                swapped = true\n            end if\n        end for\n    until not swapped\nend procedure`\n  },\n  quick: {\n    name: 'Quick Sort',\n    description: 'Quick Sort is a divide-and-conquer algorithm that works by selecting a pivot element and partitioning the array around it.',\n    timeComplexity: {\n      best: 'O(n log n)',\n      average: 'O(n log n)',\n      worst: 'O(n²)'\n    },\n    spaceComplexity: 'O(log n)',\n    pseudocode: `procedure quickSort(A: list of sortable items, low: int, high: int)\n    if low < high then\n        pivot = partition(A, low, high)\n        quickSort(A, low, pivot - 1)\n        quickSort(A, pivot + 1, high)\n    end if\nend procedure\n\nprocedure partition(A: list of sortable items, low: int, high: int)\n    pivot = A[high]\n    i = low - 1\n    for j = low to high - 1 do\n        if A[j] ≤ pivot then\n            i = i + 1\n            swap(A[i], A[j])\n        end if\n    end for\n    swap(A[i + 1], A[high])\n    return i + 1\nend procedure`\n  },\n  merge: {\n    name: 'Merge Sort',\n    description: 'Merge Sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves.',\n    timeComplexity: {\n      best: 'O(n log n)',\n      average: 'O(n log n)',\n      worst: 'O(n log n)'\n    },\n    spaceComplexity: 'O(n)',\n    pseudocode: `procedure mergeSort(A: list of sortable items, left: int, right: int)\n    if left < right then\n        middle = (left + right) / 2\n        mergeSort(A, left, middle)\n        mergeSort(A, middle + 1, right)\n        merge(A, left, middle, right)\n    end if\nend procedure\n\nprocedure merge(A: list, left: int, middle: int, right: int)\n    create temporary arrays L and R\n    copy A[left..middle] to L\n    copy A[middle+1..right] to R\n    i = 0, j = 0, k = left\n    while i < length(L) and j < length(R) do\n        if L[i] <= R[j] then\n            A[k] = L[i]\n            i = i + 1\n        else\n            A[k] = R[j]\n            j = j + 1\n        end if\n        k = k + 1\n    end while\n    copy remaining elements of L and R if any\nend procedure`\n  },\n  heap: {\n    name: 'Heap Sort',\n    description: 'Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. It builds a max-heap and repeatedly extracts the maximum element.',\n    timeComplexity: {\n      best: 'O(n log n)',\n      average: 'O(n log n)',\n      worst: 'O(n log n)'\n    },\n    spaceComplexity: 'O(1)',\n    pseudocode: `procedure heapSort(A: list of sortable items)\n    buildMaxHeap(A)\n    for i = length(A) to 2 do\n        swap(A[1], A[i])\n        heapSize = heapSize - 1\n        maxHeapify(A, 1)\n    end for\nend procedure\n\nprocedure buildMaxHeap(A: list of sortable items)\n    heapSize = length(A)\n    for i = length(A)/2 to 1 do\n        maxHeapify(A, i)\n    end for\nend procedure\n\nprocedure maxHeapify(A: list of sortable items, i: int)\n    left = 2i\n    right = 2i + 1\n    if left ≤ heapSize and A[left] > A[i] then\n        largest = left\n    else\n        largest = i\n    end if\n    if right ≤ heapSize and A[right] > A[largest] then\n        largest = right\n    end if\n    if largest ≠ i then\n        swap(A[i], A[largest])\n        maxHeapify(A, largest)\n    end if\nend procedure`\n  }\n};\n\nconst AlgorithmExplanation = ({ activeAlgorithm }) => {\n  const algorithm = algorithmInfo[activeAlgorithm];\n\n  if (!algorithm) return null;\n\n  return (\n    <div className=\"algorithm-explanation\">\n      <h2>{algorithm.name}</h2>\n      <div className=\"algorithm-description\">\n        <p>{algorithm.description}</p>\n      </div>\n      <div className=\"complexity-info\">\n        <h3>Time Complexity</h3>\n        <ul>\n          <li>Best Case: {algorithm.timeComplexity.best}</li>\n          <li>Average Case: {algorithm.timeComplexity.average}</li>\n          <li>Worst Case: {algorithm.timeComplexity.worst}</li>\n        </ul>\n        <h3>Space Complexity</h3>\n        <p>{algorithm.spaceComplexity}</p>\n      </div>\n      <div className=\"pseudocode\">\n        <h3>Pseudocode</h3>\n        <pre>{algorithm.pseudocode}</pre>\n      </div>\n    </div>\n  );\n};\n\nexport default AlgorithmExplanation; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}